<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vanning Planner v0.4o (toCSV 一本化)</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='4' y='12' width='56' height='40' rx='6' ry='6' fill='%230d47a1'/%3E%3Crect x='10' y='18' width='44' height='28' rx='2' ry='2' fill='%23ffffff'/%3E%3C/svg%3E">
  <style>
    :root{ --bg:#f6f8fb; --panel:#fff; --border:#d8e0ea; --muted:#6b7b8e; --brand:#0d47a1; --accent:#1976d2; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif; background: var(--bg); color:#111; }
    header { background: var(--brand); color:#fff; padding:16px 24px; box-shadow:0 2px 8px rgba(0,0,0,0.2); }
    header h1 { margin:0 0 4px 0; font-size:20px; }
    main { padding:16px; display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:1000px){ main{ grid-template-columns:480px 1fr; } }
    @media (min-width:1400px){ main{ grid-template-columns:520px 1fr 1fr; } }
    .panel { background:var(--panel); border-radius:12px; padding:16px; box-shadow:0 1px 4px rgba(0,0,0,0.08); }
    .items,.containers{ overflow:auto; max-height:360px; border:1px solid var(--border); border-radius:8px; }
    table{ width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed; font-size:12px; }
    thead th{ position:sticky; top:0; background:#fff; z-index:1; }
    th,td{ border-bottom:1px solid #eee; padding:6px 8px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .sw,.sw input[type="color"]{ width:42px; min-width:42px; text-align:center; }
    #viewer{ width:100%; height:clamp(360px,55vh,640px); background:#f7fafc; border-radius:8px; overflow:hidden; border:1px solid var(--border); }
    .legend{ display:flex; gap:10px; flex-wrap:wrap; font-size:12px; margin-top:6px; max-height:96px; overflow:auto; padding-right:6px; }
    .chip{ display:flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; background:#fff; border:1px solid #dde6f2; }
    .dot{ width:12px; height:12px; border-radius:50%; border:1px solid #999; }
    .plan{ overflow:auto; max-height:300px; border:1px solid var(--border); border-radius:8px; }
    button{ padding:8px 12px; border:1px solid rgba(0,0,0,0.05); border-radius:10px; background:var(--accent); color:#fff; font-weight:600; cursor:pointer; }
    button.secondary{ background:#607d8b; }
    .muted{ color:var(--muted); font-size:12px; }
    .errorBanner{ display:none; background:#fdecea; color:#b71c1c; border:1px solid #f5c6c4; padding:10px; border-radius:8px; font-size:12px; margin-top:8px; white-space:pre-wrap; }
  </style>

  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.161.0/build/three.module.js" } }
  </script>
</head>
<body>
  <header>
    <h1>Vanning Planner v0.4o</h1>
    <p>CSV強化 / 段積みポリシー / <b>toCSV一本化</b></p>
  </header>

  <main>
    <section class="panel">
      <h2>コンテナ計画</h2>
      <div class="containers">
        <table id="contTable">
          <colgroup><col style="width:52px"><col style="width:100px"><col style="width:100px"><col style="width:100px"><col style="width:100px"><col style="width:100px"><col style="width:84px"></colgroup>
          <thead><tr><th>#</th><th>タイプ</th><th>L</th><th>W</th><th>H</th><th>Max kg</th><th></th></tr></thead>
          <tbody id="contBody"></tbody>
        </table>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px">
        <button id="btnAddCont">＋ コンテナ追加</button>
        <label>表示コンテナ <select id="viewCont" style="min-width:160px"></select></label>
      </div>
    </section>

    <section class="panel">
      <h2>貨物(梱包箱)一覧</h2>
      <div class="items">
        <table id="itemsTable">
          <colgroup>
            <col style="width:22%"><col style="width:54px"><col style="width:86px"><col style="width:86px"><col style="width:86px"><col style="width:86px"><col style="width:86px"><col style="width:120px"><col style="width:92px"><col style="width:96px"><col style="width:84px">
          </colgroup>
          <thead>
            <tr><th>ID</th><th class="sw">色</th><th>L</th><th>W</th><th>H</th><th>数量</th><th>重量</th><th>積み</th><th>最大段</th><th>水平回転</th><th></th></tr>
          </thead>
          <tbody id="itemsBody"></tbody>
        </table>
      </div>
      <div style="display:flex;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-top:10px">
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="btnAddRow">行を追加</button>
          <button id="btnPack">計算する</button>
          <button id="btnClear">クリア</button>
        </div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
          <button id="btnExport">CSVエクスポート</button>
          <button id="btnImport">CSVインポート</button>
          <input type="file" id="fileInput" accept=".csv" style="display:none" />
          <label class="muted"><input type="checkbox" id="autoMode"> 即時再計算</label>
        </div>
      </div>
      <div id="totalHint" class="muted"></div>
      <div id="csvError" class="errorBanner"></div>
    </section>

    <section class="panel">
      <h2>結果と3Dビュー</h2>
      <div style="display:flex;gap:16px;flex-wrap:wrap;font-size:13px">
        <div>総箱数(選択コンテナ): <span id="statCount">0</span></div>
        <div>容積率(選択): <span id="statUtil">0%</span></div>
        <div>総重量(選択, kg): <span id="statWeight">0</span></div>
        <div class="muted">全体合計: 箱 <span id="statTotalBoxes">0</span> / 重量 <span id="statTotalWeight">0</span> kg</div>
      </div>

      <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:8px">
        <button class="secondary" id="zoomIn">＋ ズームイン</button>
        <button class="secondary" id="zoomOut">－ ズームアウト</button>
        <button class="secondary" id="zoomReset">表示をリセット</button>
        <span class="muted">ドラッグ=回転／右ドラッグ=パン／ホイール・ピンチ=ズーム</span>
      </div>

      <div id="viewer"></div>
      <div id="legend" class="legend"></div>

      <div class="plan" style="margin-top:10px">
        <h3>配置手順リスト (z, y, x 昇順) / 表示中コンテナ</h3>
        <table id="planTable">
          <thead><tr><th>#</th><th>ID</th><th>x</th><th>y</th><th>z</th><th>L</th><th>W</th><th>H</th><th>向き</th></tr></thead>
          <tbody id="planBody"></tbody>
        </table>
      </div>
    </section>

    <section class="panel">
      <h2>未配置診断（全コンテナ後も残った貨物）</h2>
      <div id="diag"></div>
    </section>
  </main>

  <footer style="text-align:center;color:#666;padding:12px 16px"><small>© 2025 Vanning Planner MVP</small></footer>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';

    const $ = (s)=>document.querySelector(s);
    const $$ = (s)=>Array.prototype.slice.call(document.querySelectorAll(s));

    const PRESETS = {
      "20DC": { l:5898,  w:2350, h:2390, maxKg:28200 },
      "20RF": { l:5450,  w:2290, h:2260, maxKg:27600 },
      "40DC": { l:12032, w:2350, h:2390, maxKg:26700 },
      "40RF": { l:11580, w:2280, h:2190, maxKg:25200 },
      "40HQ": { l:12032, w:2350, h:2690, maxKg:26400 }
    };

    // Refs
    let contBody=$("#contBody"), btnAddCont=$("#btnAddCont"), viewCont=$("#viewCont");
    let itemsBody=$("#itemsBody"), btnAddRow=$("#btnAddRow");
    let btnImport=$("#btnImport"), fileInput=$("#fileInput"), btnExport=$("#btnExport");
    let btnPack=$("#btnPack"), btnClear=$("#btnClear"), autoMode=$("#autoMode");
    let statCount=$("#statCount"), statUtil=$("#statUtil"), statWeight=$("#statWeight");
    let statTotalBoxes=$("#statTotalBoxes"), statTotalWeight=$("#statTotalWeight");
    let planBody=$("#planBody"), viewer=$("#viewer"), legend=$("#legend"), diag=$("#diag");
    let totalHint=$("#totalHint"), csvError=$("#csvError");
    let zoomInBtn=$("#zoomIn"), zoomOutBtn=$("#zoomOut"), zoomResetBtn=$("#zoomReset");

    const sanitizeInt=(v,def)=>{ const n=parseInt(String(v).trim(),10); return isFinite(n)?n:def; };
    const sanitizeFloat=(v,def)=>{ const n=parseFloat(String(v).trim()); return isFinite(n)?n:def; };
    const truthy=(s)=> String(s||'').trim().toLowerCase() in { '1':1, 'true':1, 'yes':1, 'y':1 };

    // ---------- CSV Parser & I/O (SINGLE toCSV) ----------
    function cleanText(raw){
      if(!raw) return '';
      let t = raw;
      if(t.charCodeAt(0)===0xFEFF){ t = t.slice(1); }
      t = t.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]+/g,''); // keep \n \t
      t = t.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
      return t;
    }
    function detectDelimiter(text){
      const candidates=[',',';','\t'];
      let best=','; let bestScore=-1;
      const lines=text.split('\n').slice(0,50).filter(Boolean);
      for(const d of candidates){
        const counts = lines.map(l=> l.split(d).length);
        const variance = Math.abs(Math.max(...counts)-Math.min(...counts));
        const score = Math.max(...counts);
        if(variance===0 && score>bestScore){ best=d; bestScore=score; }
      }
      return best;
    }
    function parseCSVWithDelim(text, delim){
      const rows=[]; let row=[], field='', inQuotes=false;
      for(let i=0;i<text.length;i++){
        const ch=text[i];
        if(ch==='\"'){
          if(inQuotes && text[i+1]==='\"'){ field+='\"'; i++; }
          else { inQuotes=!inQuotes; }
        }else if(ch===delim && !inQuotes){
          row.push(field); field='';
        }else if(ch==='\n' && !inQuotes){
          row.push(field); rows.push(row); row=[]; field='';
        }else{
          field+=ch;
        }
      }
      if(field.length>0 || inQuotes || row.length>0){ row.push(field); rows.push(row); }
      return rows.filter(r=> r.some(c=> String(c).trim()!=='' ));
    }
    function parseCSVAuto(text){
      const t = cleanText(text);
      let delim = detectDelimiter(t);
      let rows = parseCSVWithDelim(t, delim);
      if(rows.length<=1 || (rows[0] && rows[0].length<=1 && (t.indexOf('\t')>=0 || t.indexOf(';')>=0))){
        if(t.indexOf('\t')>=0){ delim='\t'; rows=parseCSVWithDelim(t, '\t'); }
        else if(t.indexOf(';')>=0){ delim=';'; rows=parseCSVWithDelim(t, ';'); }
      }
      return { rows, delim };
    }
    function normalizeHeader(h){ return (h||'').trim().toLowerCase(); }
    function fromCSV(text){
      const {rows} = parseCSVAuto(text);
      if(!rows.length) return [];
      const header = rows[0].map(normalizeHeader);
      const hasHeader = header.some(h=> ['id','color','l','w','h','qty','kg','rot','stack','maxstack'].includes(h));
      const dataRows = hasHeader ? rows.slice(1) : rows;
      const idx = (name, fb) => { const i=header.indexOf(name); return (hasHeader && i>=0) ? i : fb; };
      const results=[];
      for(let r=0; r<dataRows.length; r++){
        const cols=dataRows[r];
        const pos = {
          id:   idx('id',   0),
          color:idx('color', (hasHeader?-1: (cols.length>=9?1:(cols.length>=7?-1:-1)))),
          l:    idx('l',    (hasHeader?-1: (cols.length>=9?2:1))),
          w:    idx('w',    (hasHeader?-1: (cols.length>=9?3:2))),
          h:    idx('h',    (hasHeader?-1: (cols.length>=9?4:3))),
          qty:  idx('qty',  (hasHeader?-1: (cols.length>=9?5:4))),
          kg:   idx('kg',   (hasHeader?-1: (cols.length>=9?6:5))),
          rot:  idx('rot',  (hasHeader?-1: (cols.length>=9?7:6))),
          stack:idx('stack',(hasHeader?-1: (cols.length>=9?8:-1))),
          maxs: idx('maxstack',(hasHeader?-1: (cols.length>=10?9:-1)))
        };
        const get=(i)=> (i>=0 && i<cols.length)? cols[i] : '';
        const id = String(get(pos.id)||'').trim(); if(!id) continue;
        const color = (get(pos.color)||'').trim() || autoColor(r);
        const l = Math.max(1, sanitizeInt(get(pos.l), 0));
        const w = Math.max(1, sanitizeInt(get(pos.w), 0));
        const h = Math.max(1, sanitizeInt(get(pos.h), 0));
        const qty = Math.max(1, sanitizeInt(get(pos.qty), 1));
        const kg  = Math.max(0, sanitizeFloat(get(pos.kg), 0));
        const rot = truthy((get(pos.rot)||'').trim());
        let stack = (get(pos.stack)||'').trim().toLowerCase();
        if(!stack) stack = 'yes';
        if(stack!=='no' && stack!=='yes' && stack!=='same') stack='yes';
        const maxStack = Math.max(1, sanitizeInt(get(pos.maxs), 2));
        results.push({id, color, l, w, h, qty, kg, rot, stack, maxStack});
      }
      return results;
    }
    function toCSV(items){
      const head='id,color,l,w,h,qty,kg,rot,stack,maxStack';
      const escape=(v)=> /[",\n;\t]/.test(String(v)) ? '"' + String(v).replace(/"/g,'""') + '"' : String(v);
      const lines = items.map(r=>[r.id,r.color,r.l,r.w,r.h,r.qty,r.kg,(r.rot?1:0),r.stack,r.maxStack].map(escape).join(','));
      return [head].concat(lines).join('\n');
    }

    // ---------- Items (color + stacking) ----------
    const autoColor=(i)=>{ const hue=(i*47)%360; return hslToHex(hue,70,55); };
    function hslToHex(h,s,l){
      s/=100; l/=100;
      const c=(1-Math.abs(2*l-1))*s, x=c*(1-Math.abs((h/60)%2-1)), m=l-c/2;
      let r=0,g=0,b=0;
      if(0<=h && h<60){ r=c; g=x; b=0; }
      else if(60<=h && h<120){ r=x; g=c; b=0; }
      else if(120<=h && h<180){ r=0; g=c; b=x; }
      else if(180<=h && h<240){ r=0; g=x; b=c; }
      else if(240<=h && h<300){ r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      const R=Math.round((r+m)*255), G=Math.round((g+m)*255), B=Math.round((b+m)*255);
      return "#" + [R,G,B].map(v=>{ const s=v.toString(16); return s.length===1?("0"+s):s; }).join("");
    }
    function addRow(row, idx){
      const color = (row && row.color) ? row.color : autoColor(typeof idx==='number'?idx:($$('#itemsBody tr').length));
      const stack = (row && row.stack) ? row.stack : 'yes';
      const maxStack = (row && row.maxStack!=null) ? row.maxStack : 2;
      const dis = (stack==='same') ? '' : 'disabled';
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td style="text-align:left"><input type="text" value="${row&&row.id?row.id:''}" placeholder="ID" /></td>
        <td class="sw"><input type="color" value="${color}" style="width:32px;height:24px;padding:0;border:none;background:none"/></td>
        <td><input type="number" value="${row&&row.l!=null?row.l:0}" min="1" step="1" /></td>
        <td><input type="number" value="${row&&row.w!=null?row.w:0}" min="1" step="1" /></td>
        <td><input type="number" value="${row&&row.h!=null?row.h:0}" min="1" step="1" /></td>
        <td><input type="number" value="${row&&row.qty!=null?row.qty:1}" min="1" step="1" /></td>
        <td><input type="number" value="${row&&row.kg!=null?row.kg:0}" min="0" step="0.01" /></td>
        <td><select class="stackSel">
            <option value="no" ${stack==='no'?'selected':''}>段積み不可</option>
            <option value="yes" ${stack==='yes'?'selected':''}>段積み可</option>
            <option value="same" ${stack==='same'?'selected':''}>同サイズ段積み</option>
        </select></td>
        <td><input type="number" class="maxStack" value="${maxStack}" min="1" step="1" ${dis} /></td>
        <td style="text-align:center"><input type="checkbox" ${row&&row.rot?'checked':''} /></td>
        <td><button class="secondary btnDel">削除</button></td>`;
      itemsBody.appendChild(tr);
    }
    itemsBody.addEventListener('change', (e)=>{
      if(e.target.classList.contains('stackSel')){
        const tr=e.target.closest('tr'); const isSame=e.target.value==='same';
        const m=tr.querySelector('.maxStack'); if(m){ m.disabled = !isSame; }
        if(autoMode && autoMode.checked){ packAll(); }
      }
    });
    function readItems(){
      const rows=[]; let total=0,totalQty=0;
      const trs = $$('#itemsBody tr');
      for(let t=0;t<trs.length;t++){
        const ins = Array.prototype.slice.call(trs[t].querySelectorAll('input,select'));
        const id=(ins[0].value||'').trim()||('BOX'+(rows.length+1));
        const color=ins[1].value||autoColor(t);
        const l=Math.max(1,sanitizeInt(ins[2].value,0));
        const w=Math.max(1,sanitizeInt(ins[3].value,0));
        const h=Math.max(1,sanitizeInt(ins[4].value,0));
        const qty=Math.max(1,sanitizeInt(ins[5].value,1));
        const kg=Math.max(0,sanitizeFloat(ins[6].value,0));
        const stack=ins[7].value||'yes';
        const maxStack=Math.max(1,sanitizeInt(ins[8].value,1));
        const rot=!!ins[9].checked;
        rows.push({id,l,w,h,qty,kg,rot,color,stack,maxStack});
        total += kg*qty; totalQty+=qty;
      }
      totalHint.textContent = '合計箱数: '+totalQty+' / 参考総重量(kg): '+total.toFixed(1);
      return rows;
    }

    // ---------- Container UI ----------
    function addContRow(row){
      const tr=document.createElement('tr');
      const sel = '<select class="presetSel" style="width:100%">'+Object.keys(PRESETS).map(k=>`<option value="${k}" ${(row&&row.type===k)?'selected':''}>${k}</option>`).join('')+'</select>';
      tr.innerHTML=`
        <td class="idx"></td>
        <td>${sel}</td>
        <td><input type="number" class="cL" value="${row?row.l:12032}" step="1"></td>
        <td><input type="number" class="cW" value="${row?row.w:2350}" step="1"></td>
        <td><input type="number" class="cH" value="${row?row.h:2690}" step="1"></td>
        <td><input type="number" class="cMax" value="${row?row.maxKg:26400}" step="1"></td>
        <td><button class="secondary btnDelCont">削除</button></td>`;
      contBody.appendChild(tr); renumberConts();
    }
    function renumberConts(){
      const trs = $$('#contBody tr'); viewCont.innerHTML='';
      for(let i=0;i<trs.length;i++){
        const idxCell=trs[i].querySelector('.idx'); if(idxCell) idxCell.textContent=(i+1);
        const typeSel=trs[i].querySelector('.presetSel');
        const name=((typeSel&&typeSel.value)||'CTN')+' #'+(i+1);
        const opt=document.createElement('option'); opt.value=String(i); opt.textContent=name; viewCont.appendChild(opt);
      }
      if(viewCont.selectedIndex<0 && viewCont.options.length>0) viewCont.selectedIndex=0;
    }
    function readContainers(){
      const trs = $$('#contBody tr'); const out=[];
      for(let i=0;i<trs.length;i++){
        const t=trs[i];
        out.push({
          type:(t.querySelector('.presetSel')||{}).value||'40HQ',
          l:sanitizeInt((t.querySelector('.cL')||{}).value,0),
          w:sanitizeInt((t.querySelector('.cW')||{}).value,0),
          h:sanitizeInt((t.querySelector('.cH')||{}).value,0),
          maxKg:sanitizeInt((t.querySelector('.cMax')||{}).value,0)
        });
      }
      return out;
    }
    contBody.addEventListener('change',(e)=>{
      const tr=e.target.closest('tr'); if(!tr) return;
      if(e.target.classList.contains('presetSel')){
        const p=PRESETS[e.target.value]; if(p){
          tr.querySelector('.cL').value=p.l; tr.querySelector('.cW').value=p.w; tr.querySelector('.cH').value=p.h; tr.querySelector('.cMax').value=p.maxKg;
        }
      }
      if(autoMode && autoMode.checked) packAll();
    });
    contBody.addEventListener('click',(e)=>{
      if(e.target.classList.contains('btnDelCont')){ const tr=e.target.closest('tr'); if(tr) tr.remove(); renumberConts(); packAll(); }
    });
    btnAddCont.addEventListener('click',()=>{ const p=PRESETS['20DC']; addContRow({type:'20DC',...p}); packAll(); });
    viewCont.addEventListener('change',()=>renderSelectedContainer());

    // ---------- Packing ----------
    const orientations=(L,W,H,rot)=> rot ? [{l:L,w:W,h:H,name:'LxW'},{l:W,w:L,h:H,name:'WxL'}] : [{l:L,w:W,h:H,name:'LxW'}];
    const overlap=(a,b)=> !((a.x+a.l<=b.x)||(b.x+b.l<=a.x)||(a.y+a.w<=b.y)||(b.y+b.w<=a.y)||(a.z+a.h<=b.z)||(b.z+b.h<=a.z));
    const inBounds=(x,y,z,l,w,h,c)=> (x>=0 && y>=0 && z>=0 && x+l<=c.l && y+w<=c.w && z+h<=c.h);
    const placementScore=(p)=> p.z*1e12 + p.y*1e6 + p.x;
    function uniqPoints(arr){ const seen=new Set(), out=[]; for(const p of arr){ const k=p.x+','+p.y+','+p.z; if(!seen.has(k)){ seen.add(k); out.push(p);} } return out; }
    function filterBlockedPoints(arr, placed){
      const out=[];
      outer: for(const p of arr){
        for(const b of placed){
          if(p.x>b.x && p.x<b.x+b.l && p.y>b.y && p.y<b.y+b.w && p.z>b.z && p.z<b.z+b.h){ continue outer; }
        }
        out.push(p);
      }
      return out;
    }
    function findDirectSupport(candidate, placed){
      for(const b of placed){
        if(b.x===candidate.x && b.y===candidate.y && b.l===candidate.l && b.w===candidate.w && (b.z + b.h)===candidate.z){
          return b;
        }
      }
      return null;
    }
    function canPlaceWithStackPolicy(candidate, placed){
      if(candidate.z===0) return true;
      const support = findDirectSupport(candidate, placed);
      if(candidate.stack==='same'){
        if(!support) return false;
        if(support.id!==candidate.id) return false;
        let count=1; let z=support.z;
        while(true){
          const below=placed.find(b=> b.x===candidate.x && b.y===candidate.y && b.l===candidate.l && b.w===candidate.w && (b.z + b.h)===z);
          if(below){ count++; z=below.z; } else break;
        }
        return (count + 1) <= (candidate.maxStack||1) && support.stack!=='no';
      }
      if(candidate.stack==='yes'){
        if(support && support.stack==='no') return false;
        return true;
      }
      if(candidate.stack==='no'){
        if(support && support.stack==='no') return false;
        return true;
      }
      return true;
    }
    function packSingle(cont, units){
      let placed=[], points=[{x:0,y:0,z:0}], totalKg=0;
      function tryPlace(queue){
        const unp=[];
        for(const u of queue){
          let best=null, bestScore=Infinity;
          for(const p of points){
            const O=orientations(u.L,u.W,u.H,u.rot);
            for(const o of O){
              const x=p.x,y=p.y,z=p.z;
              if(!inBounds(x,y,z,o.l,o.w,o.h,cont)) continue;
              const c={x,y,z,l:o.l,w:o.w,h:o.h,id:u.id,kg:u.kg,orientation:o.name,color:u.color,stack:u.stack,maxStack:u.maxStack};
              let ok=true;
              for(const bb of placed){ if(overlap(c,bb)){ ok=false; break; } }
              if(!ok) continue;
              if(!canPlaceWithStackPolicy(c, placed)) continue;
              const sc=placementScore(p) + (cont.h - (z+o.h))*0.001;
              if(sc<bestScore){ bestScore=sc; best=c; }
            }
          }
          if(best){
            placed.push(best); totalKg += (u.kg||0);
            const X=best.x+best.l, Y=best.y+best.w, Z=best.z+best.h;
            points.push({x:X,y:best.y,z:best.z},{x:best.x,y:Y,z:best.z},{x:best.x,y:best.y,z:Z},{x:X,y:Y,z:best.z},{x:X,y:best.y,z:Z},{x:best.x,y:Y,z:Z},{x:X,y:Y,z:Z});
            const filtered=points.filter(pt=> pt.x<=cont.l && pt.y<=cont.w && pt.z<=cont.h);
            points = uniqPoints(filterBlockedPoints(filtered, placed));
            points.sort((a,b)=>placementScore(a)-placementScore(b));
          }else{
            unp.push(u);
          }
        }
        return unp;
      }
      const cand=[], tooBig=[];
      for(const u of units){
        const O=orientations(u.L,u.W,u.H,u.rot);
        const ok = O.some(o=> inBounds(0,0,0,o.l,o.w,o.h,cont));
        (ok?cand:tooBig).push(u);
      }
      cand.sort((a,b)=> (b.L*b.W*b.H)-(a.L*a.W*a.H) || (b.H-a.H));
      let unplaced = tryPlace(cand);
      if(unplaced.length){
        unplaced.sort((a,b)=> (a.L*a.W*a.H)-(b.L*b.W*b.H) || (a.H-b.H));
        unplaced = tryPlace(unplaced);
      }
      const usedVol = placed.reduce((s,b)=>s+b.l*b.w*b.h,0);
      const util = (cont.l*cont.w*cont.h)? (usedVol/(cont.l*cont.w*cont.h)) : 0;
      return { placed, unplaced, util, totalKg, tooBig };
    }
    function expandUnits(items){
      const arr=[];
      for(const it of items){
        const q=Math.max(0,Math.floor(it.qty||0));
        for(let j=0;j<q;j++){ arr.push({ id:it.id,L:it.l,W:it.w,H:it.h,kg:it.kg||0,rot:!!it.rot,color:it.color,stack:it.stack,maxStack:it.maxStack }); }
      }
      return arr;
    }
    let PACK_RESULT={ containers:[], leftovers:[] };
    function packAll(){
      const conts=readContainers();
      const items=readItems();
      let remaining = expandUnits(items);
      const containersOut=[];
      for(const c of conts){
        const res=packSingle({l:c.l,w:c.w,h:c.h,maxKg:c.maxKg}, remaining);
        containersOut.push({ meta:c, placed:res.placed, util:res.util, totalKg:res.totalKg });
        const used=new Set();
        for(const pp of res.placed){
          for(let i=0;i<remaining.length;i++){
            if(used.has(i)) continue;
            const uu=remaining[i];
            if(uu.id===pp.id && uu.L===pp.l && uu.W===pp.w && uu.H===pp.h && uu.kg===pp.kg && uu.color===pp.color && uu.stack===pp.stack && uu.maxStack===pp.maxStack){
              used.add(i); break;
            }
          }
        }
        const next=[]; for(let i=0;i<remaining.length;i++){ if(!used.has(i)) next.push(remaining[i]); }
        remaining = next;
        if(remaining.length===0) break;
      }
      PACK_RESULT={ containers:containersOut, leftovers:remaining };
      let totalBoxes=0,totalWeight=0;
      for(const c of containersOut){ totalBoxes+=c.placed.length; totalWeight+=c.totalKg; }
      statTotalBoxes.textContent=String(totalBoxes);
      statTotalWeight.textContent=totalWeight.toFixed(1);
      renumberConts();
      if(viewCont.options.length>0 && viewCont.selectedIndex<0) viewCont.selectedIndex=0;
      renderSelectedContainer();
      renderDiag();
    }

    function renderDiag(){
      const left=PACK_RESULT.leftovers||[];
      const wrap=document.createElement('div');
      if(left.length){
        const h2=document.createElement('div'); h2.textContent='ℹ 全コンテナに積めなかった箱: '+left.length+' 箱'; wrap.appendChild(h2);
        const ul2=document.createElement('ul'); const cnt=Math.min(20,left.length);
        for(let i=0;i<cnt;i++){ const s=left[i]; const li=document.createElement('li'); li.textContent=s.id+' ('+s.L+'/'+s.W+'/'+s.H+')'; ul2.appendChild(li); }
        if(left.length>cnt){ const li=document.createElement('li'); li.textContent='...他 '+(left.length-cnt)+' 箱'; ul2.appendChild(li); }
        wrap.appendChild(ul2);
      }else{
        const ok=document.createElement('div'); ok.textContent='✅ すべての貨物を割当できました。'; wrap.appendChild(ok);
      }
      diag.innerHTML=''; diag.appendChild(wrap);
    }
    function writePlanTable(placed){
      planBody.innerHTML='';
      const list=placed.slice().sort((a,b)=>(a.z-b.z)||(a.y-b.y)||(a.x-b.x));
      list.forEach((p,i)=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${i+1}</td><td style="text-align:left">${p.id}</td><td>${p.x}</td><td>${p.y}</td><td>${p.z}</td><td>${p.l}</td><td>${p.w}</td><td>${p.h}</td><td>${p.orientation||''}</td>`;
        planBody.appendChild(tr);
      });
    }

    // 3D viewer
    let scene,camera,renderer,controls,containerGroup;
    function init3D(){
      scene=new THREE.Scene();
      const aspect=viewer.clientWidth/Math.max(1,viewer.clientHeight);
      camera=new THREE.PerspectiveCamera(50,aspect,1,100000);
      camera.position.set(-3000,3000,4500);
      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setClearColor(0xf6f9ff,1);
      renderer.setSize(viewer.clientWidth, viewer.clientHeight);
      viewer.innerHTML=''; viewer.appendChild(renderer.domElement);
      const d1=new THREE.DirectionalLight(0xffffff,0.9); d1.position.set(2,3,4); scene.add(d1);
      const d2=new THREE.DirectionalLight(0xffffff,0.6); d2.position.set(-2,2,-3); scene.add(d2);
      scene.add(new THREE.AmbientLight(0xffffff,0.6));
      scene.add(new THREE.GridHelper(8000,40,0xcccccc,0xeeeeee));
      controls=new OrbitControls(camera, renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.08; controls.enablePan=true; controls.enableZoom=true;
      controls.target.set(0,0,0); camera.lookAt(controls.target);
      window.addEventListener('resize',()=>{ const w=viewer.clientWidth, h=Math.max(1,viewer.clientHeight); camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); });
      animate();
    }
    function animate(){ requestAnimationFrame(animate); if(controls) controls.update(); renderer.render(scene,camera); }
    function clearScene(){
      if(!scene) return;
      const survivors=[];
      for(const o of scene.children){ const k=o.userData&&o.userData.kind; if(k==='container'||k==='box'||k==='boxEdge') continue; survivors.push(o); }
      scene.children=survivors; containerGroup=null;
    }
    function drawContainer(L,W,H){
      const s=0.2;
      const group=new THREE.Group(); group.userData.kind='container';
      const geo=new THREE.BoxGeometry(L*s,H*s,W*s);
      const face=new THREE.MeshPhongMaterial({color:0x9ad1ff,transparent:true,opacity:0.15,depthWrite:false});
      const mesh=new THREE.Mesh(geo, face); mesh.position.set((L*s)/2,(H*s)/2,(W*s)/2); mesh.userData.kind='container'; group.add(mesh);
      const edges=new THREE.EdgesGeometry(geo);
      const line=new THREE.LineSegments(edges,new THREE.LineBasicMaterial({color:0x0059b3}));
      line.position.copy(mesh.position); line.userData.kind='container'; group.add(line);
      scene.add(group); containerGroup=group;
      controls.target.set((L*s)/2,(H*s)/2,(W*s)/2); camera.lookAt(controls.target);
    }
    const hexToThree=(hex)=> new THREE.Color(hex);
    const darker=(hex)=>{ const c=new THREE.Color(hex); c.offsetHSL(0,0,-0.2); return "#"+c.getHexString(); };
    function drawBoxes(placed){
      if(!containerGroup) return;
      const s=0.2;
      for(const p of placed){
        const geo=new THREE.BoxGeometry(p.l*s,p.h*s,p.w*s);
        const mat=new THREE.MeshPhongMaterial({color:hexToThree(p.color),transparent:true,opacity:0.92});
        const mesh=new THREE.Mesh(geo,mat); mesh.userData.kind='box';
        mesh.position.set((p.x+p.l/2)*s,(p.z+p.h/2)*s,(p.y+p.w/2)*s);
        const e=new THREE.EdgesGeometry(geo);
        const l=new THREE.LineSegments(e,new THREE.LineBasicMaterial({color:hexToThree(darker(p.color))}));
        l.userData.kind='boxEdge'; l.position.copy(mesh.position);
        scene.add(mesh); scene.add(l);
      }
    }
    function renderLegend(items){
      legend.innerHTML='';
      const seen=new Set();
      for(const it of items){
        const key=it.id+'|'+it.color; if(seen.has(key)) continue; seen.add(key);
        const chip=document.createElement('div'); chip.className='chip';
        const dot=document.createElement('span'); dot.className='dot'; dot.style.background=it.color;
        const lab=document.createElement('span'); lab.textContent=it.id;
        chip.appendChild(dot); chip.appendChild(lab); legend.appendChild(chip);
      }
    }
    zoomInBtn.addEventListener('click',()=>{ if(controls) controls.dollyIn(1.15); });
    zoomOutBtn.addEventListener('click',()=>{ if(controls) controls.dollyOut(1.15); });
    zoomResetBtn.addEventListener('click',()=>{ if(controls) controls.reset(); });

    function renderSelectedContainer(){
      let idx=sanitizeInt(viewCont.value,0);
      const conts=readContainers(); if(!conts.length){ clearScene(); return; }
      if(idx<0||idx>=conts.length) idx=0;
      const cont=conts[idx];
      const data=PACK_RESULT.containers[idx]||{placed:[], util:0, totalKg:0};
      statCount.textContent=String(data.placed.length);
      statUtil.textContent=(data.util*100).toFixed(1)+'%';
      statWeight.textContent=data.totalKg.toFixed(1);
      writePlanTable(data.placed);
      clearScene(); drawContainer(cont.l,cont.w,cont.h); drawBoxes(data.placed);
      const items=readItems().map(it=>({id:it.id,color:it.color}));
      renderLegend(items);
    }

    // Wire
    itemsBody.addEventListener('click',(e)=>{ if(e.target.classList.contains('btnDel')){ const tr=e.target.closest('tr'); if(tr) tr.remove(); packAll(); } });
    btnAddRow.addEventListener('click',()=>{ addRow({id:'',l:300,w:200,h:150,qty:1,kg:10,rot:true,stack:'yes',maxStack:2}); if(autoMode.checked) packAll(); });
    itemsBody.addEventListener('input',()=>{ if(autoMode.checked) packAll(); });
    btnExport.addEventListener('click',()=>{ const csv=toCSV(readItems()); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='items_export.csv'; a.click(); });
    btnImport.addEventListener('click',()=> fileInput.click());
    function showCsvError(msg){
      csvError.textContent = msg;
      csvError.style.display = 'block';
      console.error('[CSV Import]', msg);
    }
    function clearCsvError(){ csvError.textContent=''; csvError.style.display='none'; }
    fileInput.addEventListener('change',(e)=>{
      clearCsvError();
      const f=e.target.files && e.target.files[0]; if(!f) return;
      const tryParse = (encoding, next)=>{
        const r=new FileReader();
        r.onload=()=>{
          try{
            const txt=String(r.result||'');
            const items=fromCSV(txt);
            if(items.length<=1 && next){
              next();
              return;
            }
            itemsBody.innerHTML=''; items.forEach((it,i)=> addRow(it,i)); packAll();
          }catch(err){
            if(next){ next(); return; }
            showCsvError('CSVの読み込み中にエラー: '+ (err&&err.message?err.message:String(err)));
          }
        };
        r.onerror=()=>{ if(next){ next(); return; } showCsvError('CSVの読み込みに失敗しました（'+encoding+'）。'); };
        r.readAsText(f, encoding);
      };
      tryParse('utf-8', ()=> tryParse('shift_jis', ()=> showCsvError('CSVの読み込みに失敗しました。UTF-8/Shift_JISのいずれでも解析できませんでした。')));
    });
    btnClear.addEventListener('click',()=>{
      itemsBody.innerHTML=''; planBody.innerHTML=''; statCount.textContent='0'; statUtil.textContent='0%'; statWeight.textContent='0';
      diag.innerHTML=''; totalHint.textContent=''; PACK_RESULT={containers:[], leftovers:[]}; clearScene(); clearCsvError();
    });
    btnPack.addEventListener('click', packAll);

    // Initial
    function addDefaultContainers(){ const p1=PRESETS['40HQ']; addContRow({type:'40HQ',...p1}); const p2=PRESETS['20DC']; addContRow({type:'20DC',...p2}); }
    function addDefaultItems(){
      const sample=[
        {id:'A-Engine', color:'#e57373', l:1200, w:1000, h:800, qty:2, kg:600, rot:true,  stack:'no',   maxStack:1},
        {id:'B-Case',   color:'#64b5f6', l:1000, w:800,  h:800, qty:6, kg:300, rot:true,  stack:'yes',  maxStack:3},
        {id:'C-Box',    color:'#81c784', l:600,  w:400,  h:400, qty:20,kg:20,  rot:true,  stack:'same', maxStack:3},
        {id:'D-Tall',   color:'#ffd54f', l:1200, w:1000, h:1600,qty:1, kg:400, rot:false, stack:'no',   maxStack:1}
      ];
      sample.forEach((it,i)=>addRow(it,i));
    }
    init3D(); addDefaultContainers(); addDefaultItems(); packAll();
  </script>
</body>
</html>